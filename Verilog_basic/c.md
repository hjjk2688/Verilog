  C언어의 포인터와 배열 관계


  C언어에서 pointer[index] 라는 배열 형태의 문법은 사실 *(pointer + index) 라는 포인터 연산의 다른 표현일
  뿐입니다. 즉, 컴파일러는 tcReg[1] 이라는 코드를 보면 *(tcReg + 1) 로 바꿔서 해석합니다.

  이것을 단계별로 나누어 보겠습니다.

  1. tcReg는 포인터 변수입니다.



   1 unsigned int * tcReg = (unsigned int *)XPAR_MYIP_TCOUNTER2_0_S00_AXI_BASEADDR;



   - 이 코드는 tcReg라는 이름의 포인터 변수를 선언한 것입니다.
   - 이 변수는 unsigned int 타입의 데이터를 가리키는 포인터이며, 그 값(주소)은 0x44A10000 입니다.
   - tcReg 자체는 배열이 아니라, 단 하나의 메모리 주소(`0x44A10000`)를 저장하고 있을 뿐입니다.

  2. 포인터 연산 (Pointer Arithmetic)


   - C언어에서 포인터에 덧셈을 하면, 단순히 주소값에 숫자를 더하는 것이 아니라 '가리키는 타입의 크기'만큼
     주소를 이동시킵니다.
   - unsigned int는 보통 4바이트 크기를 가집니다.
   - 따라서,
       - tcReg + 0 은 0x44A10000 + (0 * 4바이트)  =>  0x44A10000 주소를 의미합니다.
       - tcReg + 1 은 0x44A10000 + (1 * 4바이트)  =>  0x44A10004 주소를 의미합니다.
       - tcReg + 2 은 0x44A10000 + (2 * 4바이트)  =>  0x44A10008 주소를 의미합니다.


  3. 배열 문법 []의 진짜 의미


   - 앞서 말했듯이 tcReg[index]는 *(tcReg + index)와 완전히 동일한 코드입니다.
   - *는 포인터가 가리키는 주소에 있는 실제 데이터에 접근하는 '역참조(Dereference)' 연산자입니다.


   - `tcReg[0] = ...;` 이 코드는 컴파일러에게 이렇게 해석됩니다.
       1. tcReg + 0  => 0x44A10000 주소를 계산한다.
       2. *( ... )  => 그 주소에 있는 실제 데이터 공간에 접근한다.
       3. = ...  => 그 공간에 값을 쓴다.
      결과: 0x44A10000 번지에 값을 쓴다.


   - `tcReg[1] = ...;` 이 코드는 이렇게 해석됩니다.
       1. tcReg + 1  => 0x44A10004 주소를 계산한다.
       2. *( ... )  => 그 주소에 있는 실제 데이터 공간에 접근한다.
       3. = ...  => 그 공간에 값을 쓴다.
      결과: 0x44A10004 번지에 값을 쓴다.

  결론


  tcReg는 배열이 아니라 시작 주소(0x44A10000)를 가리키는 포인터입니다.


  하지만 C언어의 포인터 연산과 배열 문법의 관계 때문에, tcReg[0], tcReg[1]... 과 같은 배열 스타일의 코드를
  사용해서 마치 배열처럼 0x44A10000, 0x44A10004, 0x44A10008... 등 4바이트씩 건너뛰며 메모리에 접근할 수
  있는 것입니다.

---
  1. 듀티비(Duty Cycle) 계산

  결론적으로 듀티비(Duty Cycle)는 50%입니다.


  계산은 다음과 같습니다.

   - `ARR (주기) 값`: 100000000 - 1
   - `CCR (비교) 값`: (100000000 / 2) - 1


  듀티비는 전체 주기(ARR) 중에서 HIGH 신호가 차지하는 비율(CCR)이므로, 간단히 (CCR 값) / (ARR 값) 으로
  계산할 수 있습니다.


  > 듀티비(%) = ( (100000000 / 2) - 1 ) / ( 100000000 - 1 ) * 100


  여기서 양쪽에 동일하게 -1이 있는 것은, 카운터가 0부터 시작하기 때문에 'N-1' 값을 넣어주기 위한 일반적인
  관례입니다. 두 값이 매우 크기 때문에 -1은 계산 결과에 거의 영향을 주지 않으며, 실질적으로 아래와 같이
  계산됩니다.


  > 듀티비(%) ≈ (100000000 / 2) / 100000000 * 100 = 0.5 * 100 = 50%


  따라서 듀티비는 정확히 50%가 됩니다.
