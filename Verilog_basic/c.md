# C언어 및 임베디드 시스템 주요 개념

---

## C언어: 포인터와 배열의 관계

C언어에서 `pointer[index]` 라는 배열 형태의 문법은 사실 `*(pointer + index)` 라는 포인터 연산의 다른 표현일 뿐입니다. 즉, 컴파일러는 `tcReg[1]` 이라는 코드를 보면 `*(tcReg + 1)` 로 바꿔서 해석합니다.

### 1. 포인터 변수 선언

```c
unsigned int * tcReg = (unsigned int *)XPAR_MYIP_TCOUNTER2_0_S00_AXI_BASEADDR;
```

- 이 코드는 `tcReg`라는 이름의 **포인터 변수**를 선언한 것입니다.
- 이 변수는 `unsigned int` 타입의 데이터를 가리키는 포인터이며, 그 값(주소)은 `0x44A10000` 입니다.
- `tcReg` 자체는 배열이 아니라, 단 하나의 메모리 주소(`0x44A10000`)를 저장하고 있을 뿐입니다.

### 2. 포인터 연산 (Pointer Arithmetic)

C언어에서 포인터에 덧셈을 하면, 단순히 주소값에 숫자를 더하는 것이 아니라 **'가리키는 타입의 크기'** 만큼 주소를 이동시킵니다. `unsigned int`는 보통 4바이트 크기를 가집니다.

- `tcReg + 0` 은 `0x44A10000 + (0 * 4바이트)` => `0x44A10000` 주소를 의미합니다.
- `tcReg + 1` 은 `0x44A10000 + (1 * 4바이트)` => `0x44A10004` 주소를 의미합니다.
- `tcReg + 2` 은 `0x44A10000 + (2 * 4바이트)` => `0x44A10008` 주소를 의미합니다.

### 3. 배열 문법 `[]`의 진짜 의미

`tcReg[index]`는 `*(tcReg + index)`와 완전히 동일한 코드입니다. `*`는 포인터가 가리키는 주소에 있는 실제 데이터에 접근하는 '역참조(Dereference)' 연산자입니다.

- **`tcReg[0] = ...;`** 이 코드는 컴파일러에게 이렇게 해석됩니다.
  1. `tcReg + 0` => `0x44A10000` 주소를 계산한다.
  2. `*( ... )` => 그 주소에 있는 실제 데이터 공간에 접근한다.
  3. `= ...` => 그 공간에 값을 쓴다.
  **결과**: `0x44A10000` 번지에 값을 쓴다.

- **`tcReg[1] = ...;`** 이 코드는 이렇게 해석됩니다.
  1. `tcReg + 1` => `0x44A10004` 주소를 계산한다.
  2. `*( ... )` => 그 주소에 있는 실제 데이터 공간에 접근한다.
  3. `= ...` => 그 공간에 값을 쓴다.
  **결과**: `0x44A10004` 번지에 값을 쓴다.

### 결론

`tcReg`는 배열이 아니라 시작 주소(`0x44A10000`)를 가리키는 포인터입니다.

하지만 C언어의 포인터 연산과 배열 문법의 관계 때문에, `tcReg[0]`, `tcReg[1]`... 과 같은 배열 스타일의 코드를 사용해서 마치 배열처럼 `0x44A10000`, `0x44A10004`, `0x44A10008`... 등 4바이트씩 건너뛰며 메모리에 접근할 수 있는 것입니다.

---

## 임베디드 시스템 및 PWM

### 용어 정리

- **MICOM (Microcomputer)**: CPU, 메모리(ROM, RAM), 소규모 주변장치(Peripheral)가 통합된 작은 컴퓨터 시스템입니다. (예: STM32)
- **SOC (System on Chip)**: 하나의 칩에 완전한 컴퓨터 시스템을 구현한 것입니다. CPU, 메모리(주로 외부에 큰 메모리 사용), 그리고 Wi-Fi, 마이크 등 사용자에 특화된 대규모 주변장치를 포함합니다.
- **CPU (Central Processing Unit)**: 중앙 처리 장치. (Intel에서 만든 용어)
- **MPU (Micro Processing Unit)**: 마이크로프로세서 장치.

### STM32 타이머: ARR과 CCR (PWM)

#### 1. ARR (Auto-Reload Register) - 주기(주파수) 결정

- **역할**: 카운터가 0부터 시작해서 얼마까지 카운트할지를 정하는 최댓값 또는 주기(Period) 값입니다. (카운터의 "천정값")
- **동작**: 타이머 카운터(CNT)는 0부터 1씩 증가하다가 ARR 레지스터에 설정된 값에 도달하면, 다음 클럭에 0으로 리셋되고 '업데이트 이벤트(Update Event)'를 발생시킵니다. 이 한 사이클이 PWM의 한 주기가 됩니다.
- **주파수 결정**: 이 주기가 반복되는 속도가 바로 주파수입니다. 따라서 ARR 값은 PWM 신호의 주파수를 결정합니다. (정확히는 시스템 클럭과 분주비(Prescaler)와 함께 결정됩니다.)
  > `PWM 주파수 = Timer 클럭 / ((Prescaler + 1) * (ARR + 1))`

#### 2. CCR (Capture/Compare Register) - 듀티비(Duty Cycle) 결정

- **역할**: PWM 모드에서는 비교(Compare) 값으로 사용됩니다. 0부터 ARR까지 증가하는 카운터(CNT) 값과 CCR 값을 실시간으로 비교하는 역할을 합니다.
- **동작**:
  - 카운터(CNT) 값이 CCR 값보다 작을 때는 출력 신호를 HIGH로 유지합니다.
  - 카운터(CNT) 값이 CCR 값보다 커지면 LOW로 변경합니다. (이는 PWM 모드 설정에 따라 반대일 수도 있습니다.)
- **듀티비 결정**: 결국 ARR이라는 전체 주기 중에서 CCR 값만큼의 시간 동안만 HIGH 신호가 나가게 됩니다. 이것이 바로 듀티비(Duty Cycle)입니다.
  > `듀티비(%) = (CCR 값 / ARR 값) * 100`

#### 요약 및 비유

- **ARR**: "오늘 하루는 총 100분이야" 라고 전체 시간을 정하는 것 (주기).
- **CCR**: "그 100분 중에서 30분까지만 불을 켜둘 거야" 라고 특정 시점을 정하는 것 (듀티비).

> **결론: ARR로 주파수를 설정하고, CCR로 그 주파수 내에서 HIGH 신호의 폭(듀티비)을 조절합니다.**

### TCounter 듀티비 계산

> 결론적으로 듀티비(Duty Cycle)는 **50%**입니다.

계산은 다음과 같습니다.

- **ARR (주기) 값**: `100000000 - 1`
- **CCR (비교) 값**: `(100000000 / 2) - 1`

듀티비는 전체 주기(ARR) 중에서 HIGH 신호가 차지하는 비율(CCR)이므로, 간단히 `(CCR 값) / (ARR 값)` 으로 계산할 수 있습니다.

```
듀티비(%) = ( (100000000 / 2) - 1 ) / ( 100000000 - 1 ) * 100
```

여기서 양쪽에 동일하게 `-1`이 있는 것은, 카운터가 0부터 시작하기 때문에 'N-1' 값을 넣어주기 위한 일반적인 관례입니다. 두 값이 매우 크기 때문에 `-1`은 계산 결과에 거의 영향을 주지 않으며, 실질적으로 아래와 같이 계산됩니다.

```
듀티비(%) ≈ (100000000 / 2) / 100000000 * 100 = 0.5 * 100 = 50%
```

따라서 듀티비는 정확히 **50%**가 됩니다.

### 참고 자료
- <https://blog.naver.com/hjjk2688/224089816311>
