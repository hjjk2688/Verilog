  C언어의 포인터와 배열 관계


  C언어에서 pointer[index] 라는 배열 형태의 문법은 사실 *(pointer + index) 라는 포인터 연산의 다른 표현일
  뿐입니다. 즉, 컴파일러는 tcReg[1] 이라는 코드를 보면 *(tcReg + 1) 로 바꿔서 해석합니다.

  이것을 단계별로 나누어 보겠습니다.

  1. tcReg는 포인터 변수입니다.



   1 unsigned int * tcReg = (unsigned int *)XPAR_MYIP_TCOUNTER2_0_S00_AXI_BASEADDR;



   - 이 코드는 tcReg라는 이름의 포인터 변수를 선언한 것입니다.
   - 이 변수는 unsigned int 타입의 데이터를 가리키는 포인터이며, 그 값(주소)은 0x44A10000 입니다.
   - tcReg 자체는 배열이 아니라, 단 하나의 메모리 주소(`0x44A10000`)를 저장하고 있을 뿐입니다.

  2. 포인터 연산 (Pointer Arithmetic)


   - C언어에서 포인터에 덧셈을 하면, 단순히 주소값에 숫자를 더하는 것이 아니라 '가리키는 타입의 크기'만큼
     주소를 이동시킵니다.
   - unsigned int는 보통 4바이트 크기를 가집니다.
   - 따라서,
       - tcReg + 0 은 0x44A10000 + (0 * 4바이트)  =>  0x44A10000 주소를 의미합니다.
       - tcReg + 1 은 0x44A10000 + (1 * 4바이트)  =>  0x44A10004 주소를 의미합니다.
       - tcReg + 2 은 0x44A10000 + (2 * 4바이트)  =>  0x44A10008 주소를 의미합니다.


  3. 배열 문법 []의 진짜 의미


   - 앞서 말했듯이 tcReg[index]는 *(tcReg + index)와 완전히 동일한 코드입니다.
   - *는 포인터가 가리키는 주소에 있는 실제 데이터에 접근하는 '역참조(Dereference)' 연산자입니다.


   - `tcReg[0] = ...;` 이 코드는 컴파일러에게 이렇게 해석됩니다.
       1. tcReg + 0  => 0x44A10000 주소를 계산한다.
       2. *( ... )  => 그 주소에 있는 실제 데이터 공간에 접근한다.
       3. = ...  => 그 공간에 값을 쓴다.
      결과: 0x44A10000 번지에 값을 쓴다.


   - `tcReg[1] = ...;` 이 코드는 이렇게 해석됩니다.
       1. tcReg + 1  => 0x44A10004 주소를 계산한다.
       2. *( ... )  => 그 주소에 있는 실제 데이터 공간에 접근한다.
       3. = ...  => 그 공간에 값을 쓴다.
      결과: 0x44A10004 번지에 값을 쓴다.

  결론


  tcReg는 배열이 아니라 시작 주소(0x44A10000)를 가리키는 포인터입니다.


  하지만 C언어의 포인터 연산과 배열 문법의 관계 때문에, tcReg[0], tcReg[1]... 과 같은 배열 스타일의 코드를
  사용해서 마치 배열처럼 0x44A10000, 0x44A10004, 0x44A10008... 등 4바이트씩 건너뛰며 메모리에 접근할 수
  있는 것입니다.
